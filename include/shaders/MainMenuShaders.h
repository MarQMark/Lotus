#ifndef LOTUS_MAINMENUSHADERS_H
#define LOTUS_MAINMENUSHADERS_H

#include <string>

static std::string MAIN_MENU_VERT =
        "#version 430\n"
        "\n"
        "layout(location = 0) in float textureSlot;\n"
        "layout(location = 1) in vec4 position;\n"
        "layout(location = 2) in vec2 texCoords;\n"
        "layout(location = 3) in vec4 color;\n"
        "\n"
        "out vec4 v_color;\n"
        "out vec2 v_texCoords;\n"
        "out float v_textureSlot;\n"
        "\n"
        "void main() {\n"
        "    v_color = color;\n"
        "    v_texCoords = texCoords;\n"
        "    v_textureSlot = textureSlot;\n"
        "    gl_Position = position;\n"
        "}";

static std::string MAIN_MENU_FRAG =
        "#version 410 core\n"
        "\n"
        "in vec4 v_color;\n"
        "in vec2 v_texCoords;\n"
        "in float v_textureSlot;\n"
        "\n"
        "layout(location = 0) out vec4 fragColor;\n"
        "\n"
        "uniform vec2 u_resolution;\n"
        "uniform float u_time;\n"
        "\n"
        "uint hash(uint x, uint seed) {\n"
        "    const uint m = 0x5bd1e995U;\n"
        "    uint hash = seed;\n"
        "    // process input\n"
        "    uint k = x;\n"
        "    k *= m;\n"
        "    k ^= k >> 24;\n"
        "    k *= m;\n"
        "    hash *= m;\n"
        "    hash ^= k;\n"
        "    // some final mixing\n"
        "    hash ^= hash >> 13;\n"
        "    hash *= m;\n"
        "    hash ^= hash >> 15;\n"
        "    return hash;\n"
        "}\n"
        "\n"
        "// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a\n"
        "// 3-dimensional unsigned integer input vector.\n"
        "uint hash(uvec3 x, uint seed){\n"
        "    const uint m = 0x5bd1e995U;\n"
        "    uint hash = seed;\n"
        "    // process first vector element\n"
        "    uint k = x.x;\n"
        "    k *= m;\n"
        "    k ^= k >> 24;\n"
        "    k *= m;\n"
        "    hash *= m;\n"
        "    hash ^= k;\n"
        "    // process second vector element\n"
        "    k = x.y;\n"
        "    k *= m;\n"
        "    k ^= k >> 24;\n"
        "    k *= m;\n"
        "    hash *= m;\n"
        "    hash ^= k;\n"
        "    // process third vector element\n"
        "    k = x.z;\n"
        "    k *= m;\n"
        "    k ^= k >> 24;\n"
        "    k *= m;\n"
        "    hash *= m;\n"
        "    hash ^= k;\n"
        "    // some final mixing\n"
        "    hash ^= hash >> 13;\n"
        "    hash *= m;\n"
        "    hash ^= hash >> 15;\n"
        "    return hash;\n"
        "}\n"
        "\n"
        "\n"
        "vec3 gradientDirection(uint hash) {\n"
        "    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n"
        "        case 0:\n"
        "            return vec3(1, 1, 0);\n"
        "        case 1:\n"
        "            return vec3(-1, 1, 0);\n"
        "        case 2:\n"
        "            return vec3(1, -1, 0);\n"
        "        case 3:\n"
        "            return vec3(-1, -1, 0);\n"
        "        case 4:\n"
        "            return vec3(1, 0, 1);\n"
        "        case 5:\n"
        "            return vec3(-1, 0, 1);\n"
        "        case 6:\n"
        "            return vec3(1, 0, -1);\n"
        "        case 7:\n"
        "            return vec3(-1, 0, -1);\n"
        "        case 8:\n"
        "            return vec3(0, 1, 1);\n"
        "        case 9:\n"
        "            return vec3(0, -1, 1);\n"
        "        case 10:\n"
        "            return vec3(0, 1, -1);\n"
        "        case 11:\n"
        "            return vec3(0, -1, -1);\n"
        "        case 12:\n"
        "            return vec3(1, 1, 0);\n"
        "        case 13:\n"
        "            return vec3(-1, 1, 0);\n"
        "        case 14:\n"
        "            return vec3(0, -1, 1);\n"
        "        case 15:\n"
        "            return vec3(0, -1, -1);\n"
        "    }\n"
        "}\n"
        "\n"
        "float interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n"
        "    return mix(\n"
        "        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n"
        "        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n"
        "        t.z\n"
        "    );\n"
        "}\n"
        "\n"
        "vec3 fade(vec3 t) {\n"
        "    // 6t^5 - 15t^4 + 10t^3\n"
        "    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n"
        "}\n"
        "\n"
        "float perlinNoise(vec3 position, uint seed) {\n"
        "    vec3 floorPosition = floor(position);\n"
        "    vec3 fractPosition = position - floorPosition;\n"
        "    uvec3 cellCoordinates = uvec3(floorPosition);\n"
        "    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n"
        "    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n"
        "    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n"
        "    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n"
        "    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n"
        "    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n"
        "    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n"
        "    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n"
        "    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n"
        "}\n"
        "\n"
        "float perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n"
        "    float value = 0.0;\n"
        "    float amplitude = 1.0;\n"
        "    float currentFrequency = float(frequency);\n"
        "    uint currentSeed = seed;\n"
        "    for (int i = 0; i < octaveCount; i++) {\n"
        "        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n"
        "        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n"
        "        amplitude *= persistence;\n"
        "        currentFrequency *= lacunarity;\n"
        "    }\n"
        "    return value;\n"
        "}\n"
        "\n"
        "float cloud(vec2 pos, uint seed){\n"
        "    // float frequency = 16.0;\n"
        "    // float value = perlinNoise(vec3(position, iTime * 0.25) * frequency, seed); // single octave perlin noise\n"
        "    //float value = perlinNoise(vec3(pos, 1), 2, 6, 0.5, 2.5, seed); // multiple octaves\n"
        "    float value = perlinNoise(vec3(pos, 1), 2, 6, 0.5, 2.5, seed); // multiple octaves\n"
        "    value *= 1.1;\n"
        "    value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n"
        "\n"
        "    return value;\n"
        "}\n"
        "\n"
        "\n"
        "#define SKY_COLOR vec3(195./255., 76./255., 68./255.)\n"
        "#define CLOUD_COLOR vec3(239./255., 160./255., 76./255.)\n"
        "\n"
        "#define SUN_COLOR  vec3(255./255., 254./255., 213./255.) * 1.2\n"
        "#define SUN_RADIUS 0.02\n"
        "#define SUN_OUT_COLOR vec3(241./255., 189./255., 62./255.)\n"
        "#define SUN_OUT_RADIUS 0.035\n"
        "\n"
        "#define FLOOR_COLOR vec3(29./255., 5./255., 19./255.)\n"
        "#define TREE_COLOR_1 vec3(29./255., 5./255., 19./255.) * 1.3\n"
        "#define TREE_COLOR_2 vec3(66./255., 16./255., 39./255.)\n"
        "#define TREE_COLOR_3 vec3(116./255., 38./255., 51./255.)\n"
        "\n"
        "float rand(float x){\n"
        "    return fract(sin(x)*1546455.0);\n"
        "}\n"
        "\n"
        "float tree_rand(float x){\n"
        "    return (rand(x) - .5) / 100.;\n"
        "}\n"
        "\n"
        "float tree_branch(vec2 pos, float seed){\n"
        "    float tree = 0;\n"
        "\n"
        "    vec2 off_in = vec2(.1 + tree_rand(seed * 334), 0 +  1.2*tree_rand(seed * 948));\n"
        "    vec2 off_out = vec2(.2 + tree_rand(seed * 54135), -.05 +  1.2*tree_rand(seed * 4865));\n"
        "\n"
        "    // positve tree\n"
        "    vec2 circle = pos + off_in;\n"
        "    float radius = circle.x * circle.x + circle.y * circle.y;\n"
        "    tree = step(radius, .1);\n"
        "    tree = max(tree, smoothstep(.1, radius, .1002));\n"
        "\n"
        "    // negative\n"
        "    vec2 circle2 = circle + off_out;\n"
        "    radius = circle2.x * circle2.x + circle2.y * circle2.y;\n"
        "    tree = min(tree, 1 -  step(radius, .13));\n"
        "    tree = min(tree, 1 - smoothstep(.13, radius, .1303));\n"
        "\n"
        "    tree = min(tree, step(pos.x, 0));\n"
        "    tree = min(tree, step(pos.y, 0));\n"
        "\n"
        "    return tree;\n"
        "}\n"
        "\n"
        "float tree(vec2 pos){\n"
        "    float tree = 0;\n"
        "\n"
        "    // translate to middle\n"
        "    pos -= vec2(u_resolution.x / u_resolution.y / 2, 1);\n"
        "\n"
        "    for(float i = 0; i < 5; i++){\n"
        "        tree = max(tree, tree_branch(pos, i * 654));\n"
        "        tree = max(tree, tree_branch(pos * vec2(-1, 1), i * 845));\n"
        "\n"
        "        pos /= vec2(1.15, 1.17);\n"
        "        pos += vec2(0, .05);\n"
        "    }\n"
        "\n"
        "    return tree;\n"
        "}\n"
        "\n"
        "vec3 tree_color(float seed, float y){\n"
        "    vec3 color = TREE_COLOR_1;\n"
        "    float random = rand(seed);\n"
        "    color = mix(color, TREE_COLOR_2, step(random, .66 - 1/(7 - y)));\n"
        "    color = mix(color, TREE_COLOR_3, step(random, .33 - 1/(7 - y)));\n"
        "\n"
        "    return color;\n"
        "}\n"
        "\n"
        "void main() {\n"
        "    vec2 position = gl_FragCoord.xy/u_resolution.xy;\n"
        "    position.x *= u_resolution.x / u_resolution.y;\n"
        "\n"
        "    vec3 color = SKY_COLOR;\n"
        "\n"
        "    vec2 sun = position;\n"
        "    sun -= vec2(u_resolution.x / u_resolution.y / 2, .75);\n"
        "\n"
        "    float radius = sun.x * sun.x + sun.y * sun.y;\n"
        "    color = mix(color, SUN_OUT_COLOR, smoothstep(SUN_RADIUS, radius, SUN_OUT_RADIUS));\n"
        "    color = mix(color, SUN_COLOR, smoothstep(SUN_RADIUS, radius, SUN_RADIUS + 0.002));\n"
        "    color = mix(color, SUN_COLOR, step(radius, SUN_RADIUS));\n"
        "\n"
        "    color = mix(color, CLOUD_COLOR, cloud(position + vec2(u_time * 0.1, 0), 0x578437adU));\n"
        "    color = mix(color, SKY_COLOR, smoothstep(0., position.y, 0.3));\n"
        "\n"
        "    color = mix(color, FLOOR_COLOR, step(position.y, 0.1));\n"
        "    color = mix(color, FLOOR_COLOR, smoothstep(0.1, position.y, 0.101));\n"
        "\n"
        "    vec2 treePos = position;\n"
        "    treePos.x += u_time * .04;\n"
        "    treePos *= 2;\n"
        "\n"
        "    float nonRep = floor(treePos.x + 546);\n"
        "    treePos.x = fract(treePos.x);\n"
        "    treePos *= 10/3.05;\n"
        "    treePos.x += 0.42;\n"
        "\n"
        "    treePos.y -= .35;\n"
        "\n"
        "    for(float y = 0; y < 5; y++){\n"
        "        for(float x = 0; x < 5; x++){\n"
        "            //float randOff = 1 * (rand((4645652 * (x + 5146)) * (45421 * (y + 1645))) - .5);\n"
        "            float randOff = rand(x * nonRep *  y);\n"
        "            color = mix(color, tree_color(randOff, y), tree(treePos + vec2((x * -.6) + randOff, 0)));\n"
        "        }\n"
        "        treePos.y += .12;\n"
        "    }\n"
        "\n"
        "    gl_FragColor = vec4(color, 1.0);\n"
        "}";

#endif //LOTUS_MAINMENUSHADERS_H
